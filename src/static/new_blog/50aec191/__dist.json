{"articles": {"2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-": {"title": "Python: 相对引用和绝对引用，哪个更好?", "category": "未分类", "description": "", "date": "2023-02-23", "ref": "", "author": "", "tags": ["Python", "工程化"], "identity": "2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-", "content": "我认为在submodule中使用相对引用是合适的，但在一次提交merge request时，被一个曾任职于Google的权威的工程师拒绝了，原因是：[Google Python Style Guide](https://google.github.io/styleguide/pyguide.html) 禁止使用相对引用：\n> Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.\n\nPython的两种引用方式，其中相对引用就是以当前代码文件所在位置为参考点，引用其他模块，如：\n```python\nfrom . import xxx\nfrom ...xxx import yyy\n```\n而绝对引用，则是以入口文件或者顶级模块的位置作为参考点，引入其他模块：\n```python\nfrom xxx import yyy\nfrom xxx.yyy import zzz\n```\n有些IDE把这个入口点称为source root，其```__name__```值为```\"__main__\"```。当我们要联合两个git仓库的代码时，要使用绝对引用的方式调用submodule里的python代码，有两种途径：\n* 使main repo和submodule的source root保持一致\n* 在main repo引用submodule之前，加入一句```import sys;sys.path.append({source_root_of_submodule})```\n\n第一种方法很容易理解，Python的引用机制确保了它能够搜索到source root下的模块；而当source root不一致时，会得到一个ModuleNotFoundError，因为import参考点不一样，解释器就找不到模块的正确位置。这意味着，只能把submodule放在main repo的source root下。当submodule一多，main的source root会变得臃肿不堪。更加致命的是，如果submodule的入口点在它的子目录下（很常见，很多仓库最外层是一些licence、document等，代码放在一个叫src的子目录里），在main repo里就无法import它，因为这种代码结构注定了submodule的source root比main repo至少深一个层级。\n\n第二种方式是将submodule的source root加入到main repo的sys.path中。Python解释器在搜索不到模块时，会尝试在sys.path的对应位置查找，所以这种方式看起来是可以work的。但是，```sys.path.append```是一个非常危险的操作！submodule里的包会覆盖sys.path里的同名包，可能会对sys.path造成污染，整个过程都将是悄无声息的。运气不好的话，程序开始启动时能正常运行，但后续会在某个隐藏条件被触发时，突然的产生致命bug。\n\n以上的情形中，使用绝对引用无法避免这些问题。更优雅的解决办法是，submodule里除了main.py、test.py等这些入口文件之外，其他全部使用相对引用。这样main repo可以根据自己的代码结构，灵活地把submodule放在任意位置，此时submodule的source root取决于main的source root，不会再有冲突。\n\n其实不仅仅是google官方的pyguide不建议使用相对引用，诸多大厂的python规范都是如此，Python官方也曾一度要去除相对引用的方式，pep328还介绍了两方阵营的争论过程，但最终相对引用还是得以保留。不用相对引用的原因很多，如pyguide所述\"防止包被引用两次\"，还有它使目录结构不够清晰了然、给人容易出错的感觉等，但不使用绝对引用的理由只有一个，就是在多个代码仓库合并开发时，如果不借助pypi管理包的话，就无法统一参考点。代码规范并非在任何情况下都是金科玉律，在实践中永远要选择合适的方式。\n\n[https://docs.python.org/3.11/tutorial/modules.html#intra-package-references](https://docs.python.org/3.11/tutorial/modules.html#intra-package-references)\n[https://peps.python.org/pep-0328/](https://peps.python.org/pep-0328/)"}, "2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei": {"title": "MicroPython+rp2040操作IIS，很鸡肋", "category": "硬件", "description": "", "date": "2023-02-26", "ref": "", "author": "", "tags": ["Python", "硬件"], "identity": "2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei", "content": "## 目录\n\n* [TAS2563](#TAS2563)\n* [RP2040实现IIS](#RP2040-IIS)\n* [时隙太小，很难不间断的传输数据](#time-slot)\n* [总结](#summary)\n\n最近使用tas2563做一个音频相关的项目，想要快速验证方案，就选了用了rp2040作为主控。主要的考量是，rp2040官方加入了MicroPython的支持，在开发上占据一定的便利性。\n\n<h2 id=\"TAS2563\">TAS2563</h2>\n\ntas2563是德州仪器的一款6瓦单声道D类功放，自带DC-DC升压，在2.5v~5.5v电池供电的情况下升至11v，同时有着极高的信噪比和低失真度。它的音频数据接口为TDM，可以配置为标准IIS或者左对齐模式。数据手册中采样率相关的介绍：\n\n![](/static/new_blog/50aec191/2023-02-26/i2s.png)\n\n> The TDM serial audio port supports up to 16 32-bit time slots at 44.1/48 kHz, 8 32-bit time slots at a 88.2/96 kHz sample rate and 4 32-bit time slots at a 176.4/192 kHz sample rate. The device supports 2 time slots at 32 bits in width and 4 or 8 time slots at 16, 24 or 32 bits in width. Valid SBCLK to FSYNC ratios are 64, 96, 128, 192, 256, 384 and 512. The device will automatically detect the number of time slots and this does not need to be programmed.\n\n其中规定了SBCLK和FSYNC最低的时钟比是64，即每一帧数据至少要达到64bit，哪怕传输24bit（双声道48bit，后同理）、16bit甚至是8bit音频，也要在末尾添补0来凑齐64个时钟。这其实是个缺点，因为它强行拉高了SBCLK的时钟频率，进而也拉高了主控的时钟。\n\ntas2563的采样率最高支持96kHz，但过高的时钟频率对主控投喂数据的实效要求更高。通常认为44.1kHz的采样率已经有足够的声音表现。鉴于其总线要求，在这个采样率下，SBCLK的频率为2.8224Mhz，如果传输16bit音频，码率为1378 kbps，约172.3 KB/s。\n\n<h2 id=\"RP2040-IIS\">RP2040实现IIS</h2>\n\nrp2040没有IIS外设接口，但有两个PIO块，每个PIO块有4个状态机，共享32个槽位的指令缓存。实现一个IIS接口，使用1个状态机就够了。由于每条指令占用一个状态机时钟，可以画出标准32bit IIS时序图：\n![](/static/new_blog/50aec191/2023-02-26/ana.jpg)\n对应的程序如下：\n```python\n@asm_pio(out_init=PIO.OUT_LOW, sideset_init=(PIO.OUT_HIGH, PIO.OUT_HIGH), pull_thresh=32, autopull=True, fifo_join=PIO.JOIN_TX,)\ndef Audio_PIO():\n    # SBCLK active: rising edge\n    #                              _ FSYNC\n    #                             / _ SBCLK\n    #                             |/\n    set(x, 15)            .side(0b11)\n    label(\"high_ch\")\n    out(pins, 1)          .side(0b10)\n    jmp(x_dec,\"high_ch\")  .side(0b11)\n\n    set(x, 13)            .side(0b10)\n    label(\"high_nop\")\n    nop()                 .side(0b11)\n    jmp(x_dec,\"high_nop\") .side(0b10)\n    nop()                 .side(0b11)\n    nop()                 .side(0b00)\n\n    set(x, 15)            .side(0b01)\n    label(\"low_ch\")\n    out(pins, 1)          .side(0b00)\n    jmp(x_dec,\"low_ch\")   .side(0b01)\n\n    set(x, 13)            .side(0b00)\n    label(\"low_nop\")\n    nop()                 .side(0b01)\n    jmp(x_dec,\"low_nop\")  .side(0b00)\n    nop()                 .side(0b01)\n    nop()                 .side(0b10)\n```\n\n在主循环中，往状态机中的tx FIFO写入数据0xAAAA_5555，左右声道各16bit ，从逻辑分析仪可以看到标准信号：\n![](/static/new_blog/50aec191/2023-02-26/rp2040_iis.png)\n\n实现了这一步，已经可以让tas2563发出声音了。但如果要让它播放歌曲，才是最困难的一步。如果所有音频都存储于ROM，那直接读取就好，几乎没有任何障碍。但这是不现实的，rp2040最大仅支持16MB的ROM，如果以wav格式存储44.1kHz 16bit音频，最多也只能存90秒。所以借助外部存储是有必要的。\n\n这可以借助SD卡，从MicroPython官方文档中ESP32的章节里，可以获取一个使用SPI总线操作SD卡的实例。可以无修改的移植到rp2040上，并挂载到文件系统中：\n```python\nimport os\nfrom machine import SPI, Pin\nfrom lib import SDCard  # 移植来的SD卡操作库\n\nsd = SDCard(spi=SPI(0, baudrate=60_000_000, sck=Pin(18), mosi=Pin(19), miso=Pin(16)), cs=Pin(17))\nos.mount(sd, '/sd')\n```\n这样一来，貌似可以在主程序中从sd卡读取文件，写入到状态机的tx FIFO里就可以播放音乐。但它还是有一个致命问题。\n\n<h2 id=\"time-slot\">时隙太小，很难不间断的传输数据</h2>\n\n在44.1 kHz的采样率下，每帧的时间间隔为22.6 us，IIS是一个 __时钟严格__ 的同步总线，如果下一帧数据没有在这个时隙中准备好，就会听到失真的声音甚至爆音。将状态机的rx FIFO和tx FIFO合并，得到8个32bit的FIFO，也仅有180多us，这个时隙太短了。\n\n读SD卡的延迟太高了，远远超过了180多us。这里特别强调是延迟，因为它的带宽还可以，不是真正的阻碍。即使采用spi总线，连续读的带宽也可轻松达到1MB/s，用来驱动这个IIS足够了。最大的还是延迟的问题，假如打开一个文件并读几个字节，等待时间有时高达数毫秒，这里有一部分是MicroPython和FatFS的损耗，还有一部分是不可控的gc。同步读、同步写很难不卡的，只能借助一个更大的buffer实现异步操作。\n\n在只有264KB RAM的rp2040上，开辟一个20KB的array几乎是极限了，再大的话可能因为找不到这么大的连续内存空间而产生MemoryError，这是MicroPython的限制。在这个条件下，也只能勉强得到115毫秒的时间窗口用来准备数据。假设这个时间窗是足够的，有两种方式借助这个buffer把数据从SD卡传输到状态机里：\n* 在循环里一直读取数据，设置一个时隙稍小于180us周期性定时中断，在中断里把状态机的FIFO空间填满\n* rp2040是双核的，在一个核心里取数据，另一个核心写数据到状态机\n\n第一种方式，除非自己用C写扩展，否则无法实现。MicroPython官方的定时器，最小只能设置1ms的定时周期，已经大大超过了180us。即使如此，每次进入中断和离开中断，都有很大的性能损耗，这主要是mPy运行时和上下文切换的开销。\n\n而对于第二种方式，在两个核间共享数据，需要实现互斥锁。rp2040没有半传输中断机制，需要自己实现，在写buffer的core里不停轮训一个变量，以得知另一个core读取到buffer的哪个位置。这可能需要精细的控制时序，并且使用 [Maximising MicroPython speed](https://docs.micropython.org/en/latest/reference/speed_python.html) 技巧实现加速。但经过反复调试，还是很难保证每个180us时隙内都能取到有效数据，因为等待锁的时间是不可预知的，借助mPy文件系统读取sd卡过程中会申请内存、释放对象（即使使用了readinto到一个预申请的buff中，代替read），以及随机的gc，这些偶然因素都会造成抖动。用逻辑分析仪观察，它会偶尔出现一些空隙，造成爆音：\n![](/static/new_blog/50aec191/2023-02-26/bad_bus.png)\n\n\n<h2 id=\"summary\">总结</h2>\n\nMicroPython还是比较鸡肋。本来它和嵌入式应用场景就有些相悖，在264KB RAM的rp2040，光mPy运行时就占用了80多KB的RAM。各个模块的API也十分简略，比如ADC，它只能支持简单的单次转换，没有任何高阶功能。为了降低入门门槛、提高编程便捷性，在寸土寸金的硬件资源上，耗费了巨量的资源却只能实现很简略的功能，这个取舍到底是否值得，有待探讨。"}, "2023-03-14/-xiu-gai-bian-yi-nginx-yi-shan-chu-huo-zi-ding-yi- Server Header": {"title": "修改编译nginx以删除或自定义 \"Server\" Header", "category": "nginx", "description": "", "date": "2023-03-14", "ref": "", "author": "", "tags": ["nginx"], "identity": "2023-03-14/-xiu-gai-bian-yi-nginx-yi-shan-chu-huo-zi-ding-yi- Server Header", "content": "边缘计算等对内存极其敏感的场景下，在进行HTTP通信时往往需要移除一些不必要内容以节约内存。使用nginx正向代理时，它会添加默认的Server Header，即使在nginx.conf中指定了```server_tokens off;```，也仅仅是隐藏版本号，并未去除这个Header。\n\n## 隐藏Header\n\n这部分的逻辑在 ```src/http/ngx_http_header_filter_module.c``` 中定义:\n```C\n...\nstatic u_char ngx_http_server_string[] = \"Server: nginx\" CRLF;\nstatic u_char ngx_http_server_full_string[] = \"Server: \" NGINX_VER CRLF;\nstatic u_char ngx_http_server_build_string[] = \"Server: \" NGINX_VER_BUILD CRLF;\n...\n\nstatic ngx_int_t\nngx_http_header_filter(ngx_http_request_t *r)\n{\n   ...\n    if (r->headers_out.server == NULL) {\n        if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n            len += sizeof(ngx_http_server_full_string) - 1;\n\n        } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n            len += sizeof(ngx_http_server_build_string) - 1;\n\n        } else {\n            len += sizeof(ngx_http_server_string) - 1;\n        }\n    }\n    ...\n    b = ngx_create_temp_buf(r->pool, len);\n    ...\n    if (r->headers_out.server == NULL) {\n        if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n            p = ngx_http_server_full_string;\n            len = sizeof(ngx_http_server_full_string) - 1;\n\n        } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n            p = ngx_http_server_build_string;\n            len = sizeof(ngx_http_server_build_string) - 1;\n\n        } else {\n            p = ngx_http_server_string;\n            len = sizeof(ngx_http_server_string) - 1;\n        }\n\n        b->last = ngx_cpymem(b->last, p, len);\n    }\n```\n可以得知，在处理header时，nginx先计算header部分的内存大小，再申请一块buffer，然后进行填充，所以对```headers_out.server```进行了两次判断。可以对上述两个if判断块进行注释，这样在请求时就不会有server字段：\n```shell\n~/nginx # curl -I localhost/\n\nHTTP/1.1 200 OK\nDate: Wed, 15 Mar 2023 03:10:25 GMT\nContent-Type: text/html\nContent-Length: 615\nLast-Modified: Wed, 15 Mar 2023 02:55:32 GMT\nConnection: keep-alive\nETag: \"641133a4-267\"\nAccept-Ranges: bytes\n```\n\n## 使其可配置\n\n在```ngx_http_header_filter```可以看到```clcf```结构体，类型为```ngx_http_core_loc_conf_t```，其为conf文件中http部分配置的解析\n```C\nstruct ngx_http_core_loc_conf_s {\n    ngx_str_t     name;          /* location name */\n    ngx_str_t     escaped_name;\n\n#if (NGX_PCRE)\n    ngx_http_regex_t  *regex;\n#endif\n    ...\n    ngx_http_location_tree_node_t   *static_locations;\n#if (NGX_PCRE)\n    ngx_http_core_loc_conf_t       **regex_locations;\n#endif\n    ...\n```\n实现自定义server name，我们可以把配置添加到这个块当中，在结构体中加入:\n```C\n    // add\n    ngx_str_t     customized_server_name;\n```\n同时要处理解析配置文件的地方，nginx从这里加载配置，并等待event，在event handler当中根据addr：port等参数寻找server的配置，并组装成request对象。conf文件解析的主要逻辑在```ngx_conf_handler```等函数当中，这里遍历每个ngx_command数组，每个元素对应一条解析项，配置的解析根据其属性进行对应的处理：\n```C\nstruct ngx_command_s {\n    ngx_str_t             name;\n    ngx_uint_t            type;\n    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n    ngx_uint_t            conf;\n    ngx_uint_t            offset;\n    void                 *post;\n};\n```\n其中，其中，`name`是配置项名称，`type`决定这个配置项可以在哪些块，nginx使用位标记来标识，`set`则为设置配置的回调方法。`conf`用于指示配置项所处内存的相对偏移位置，`offset`表示当前配置项在整个存储配置项的结构体中的偏移位置。由此，可以在```src/http/ngx_http_core_module.c```中定义自定义的command：\n```C\nstatic ngx_command_t  ngx_http_core_commands[] = {\n    ...\n    \n    // add\n    { ngx_string(\"customized_server_name\"),\n      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_core_loc_conf_t, customized_server_name),\n      NULL },\n    ...\n    ngx_null_command\n}\n```\n其中`ngx_conf_set_str_slot`是nginx预置的回调函数。若在多个域同时出现配置项时，nginx需要根据某些优先规则确定使用那个配置，由此nginx实现了一个merge机制，对于没有merge函数的配置，最终不会生效。http域的merge定义在此文件```ngx_http_core_merge_loc_conf```函数中，在这里优先取子层存在的配置，若无则取上层的，否则取默认。可以添加上自定义配置项的merge函数：\n```C\nstatic char *\nngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_http_core_loc_conf_t *prev = parent;\n    ngx_http_core_loc_conf_t *conf = child;\n    ...\n    // add\n    ngx_conf_merge_str_value(conf->customized_server_name,\n                             prev->customized_server_name, \"undefined\");\n    ...\n}\n```\n由此，就可以在`ngx_http_header_filter`当中获取到此配置项，修改这两处的逻辑：\n```C\nstatic ngx_int_t\nngx_http_header_filter(ngx_http_request_t *r)\n{\n    ...\n    // modify\n    if (r->headers_out.server == NULL) {\n        if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n            len += sizeof(\"Server: \") - 1 + clcf->customized_server_name.len + 2;\n        }\n    }\n    ...\n    b = ngx_create_temp_buf(r->pool, len);\n    ...\n    \n    // modify\n    if (r->headers_out.server == NULL) {\n        if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n            p = clcf->customized_server_name.data;\n            len = clcf->customized_server_name.len;\n\n            b->last = ngx_cpymem(b->last, \"Server: \", sizeof(\"Server: \") - 1);\n            b->last = ngx_cpymem(b->last, p, len);\n            *b->last++ = CR; *b->last++ = LF;\n        }\n    }\n    ...\n```\n需要注意```len += sizeof(\"Server: \") - 1 + clcf->customized_server_name.len + 2;```计算长度时，sizeof会包含字符串结尾的`\\0`，在拷贝内容到buffer时必剔除这部分，由此需要减一。最后加2对应每条Header结束的`\\r\\n`。\n\n编译运行，并在`nginx.conf`中添加：\n```\n...\nhttp {\n    customized_server_name jjcjj;\n    \n    include       mime.types;\n    default_type  application/octet-stream;\n    ...\n```\n启动后，可以看到自定义的Server已经生效：\n```shell\n~/nginx # curl -I localhost/\n\nHTTP/1.1 200 OK\nServer: jjcjj\nDate: Wed, 15 Mar 2023 03:10:25 GMT\nContent-Type: text/html\nContent-Length: 615\nLast-Modified: Wed, 15 Mar 2023 02:55:32 GMT\nConnection: keep-alive\nETag: \"641133a4-267\"\nAccept-Ranges: bytes\n```\n当未指定`customized_server_name`时，Server会返回默认值`undefined`；添加`server_tokens off`则不会返回Server Header，效果同上文所述。"}}, "tag_map": {"Python": ["2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei", "2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-"], "工程化": ["2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-"], "硬件": ["2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei"], "nginx": ["2023-03-14/-xiu-gai-bian-yi-nginx-yi-shan-chu-huo-zi-ding-yi- Server Header"]}, "category_map": {"未分类": ["2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-"], "硬件": ["2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei"], "nginx": ["2023-03-14/-xiu-gai-bian-yi-nginx-yi-shan-chu-huo-zi-ding-yi- Server Header"]}}