{"articles": {"2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-": {"title": "Python: 相对引用和绝对引用，哪个更好?", "category": "未分类", "description": "", "date": "2023-02-23", "ref": "", "author": "", "tags": ["Python", "工程化"], "identity": "2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-", "content": "我认为在submodule中使用相对引用是合适的，但在一次提交merge request时，被一个曾任职于Google的权威的工程师拒绝了，原因是：[Google Python Style Guide](https://google.github.io/styleguide/pyguide.html) 禁止使用相对引用：\n> Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.\n\nPython的两种引用方式，其中相对引用就是以当前代码文件所在位置为参考点，引用其他模块，如：\n```python\nfrom . import xxx\nfrom ...xxx import yyy\n```\n而绝对引用，则是以入口文件或者顶级模块的位置作为参考点，引入其他模块：\n```python\nfrom xxx import yyy\nfrom xxx.yyy import zzz\n```\n有些IDE把这个入口点称为source root，其```__name__```值为```\"__main__\"```。当我们要联合两个git仓库的代码时，要使用绝对引用的方式调用submodule里的python代码，有两种途径：\n* 使main repo和submodule的source root保持一致\n* 在main repo引用submodule之前，加入一句```import sys;sys.path.append({source_root_of_submodule})```\n\n第一种方法很容易理解，Python的引用机制确保了它能够搜索到source root下的模块；而当source root不一致时，会得到一个ModuleNotFoundError，因为import参考点不一样，解释器就找不到模块的正确位置。这意味着，只能把submodule放在main repo的source root下。当submodule一多，main的source root会变得臃肿不堪。更加致命的是，如果submodule的入口点在它的子目录下（很常见，很多仓库最外层是一些licence、document等，代码放在一个叫src的子目录里），在main repo里就无法import它，因为这种代码结构注定了submodule的source root比main repo至少深一个层级。\n\n第二种方式是将submodule的source root加入到main repo的sys.path中。Python解释器在搜索不到模块时，会尝试在sys.path的对应位置查找，所以这种方式看起来是可以work的。但是，```sys.path.append```是一个非常危险的操作！submodule里的包会覆盖sys.path里的同名包，可能会对sys.path造成污染，整个过程都将是悄无声息的。运气不好的话，程序开始启动时能正常运行，但后续会在某个隐藏条件被触发时，突然的产生致命bug。\n\n以上的情形中，使用绝对引用无法避免这些问题。更优雅的解决办法是，submodule里除了main.py、test.py等这些入口文件之外，其他全部使用相对引用。这样main repo可以根据自己的代码结构，灵活地把submodule放在任意位置，此时submodule的source root取决于main的source root，不会再有冲突。\n\n其实不仅仅是google官方的pyguide不建议使用相对引用，诸多大厂的python规范都是如此，Python官方也曾一度要去除相对引用的方式，pep328还介绍了两方阵营的争论过程，但最终相对引用还是得以保留。不用相对引用的原因很多，如pyguide所述\"防止包被引用两次\"，还有它使目录结构不够清晰了然、给人容易出错的感觉等，但不使用绝对引用的理由只有一个，就是在多个代码仓库合并开发时，如果不借助pypi管理包的话，就无法统一参考点。代码规范并非在任何情况下都是金科玉律，在实践中永远要选择合适的方式。\n\n[https://docs.python.org/3.11/tutorial/modules.html#intra-package-references](https://docs.python.org/3.11/tutorial/modules.html#intra-package-references)\n[https://peps.python.org/pep-0328/](https://peps.python.org/pep-0328/)"}, "2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei": {"title": "MicroPython+rp2040操作IIS，很鸡肋", "category": "未分类", "description": "", "date": "2023-02-26", "ref": "", "author": "", "tags": ["Python", "硬件"], "identity": "2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei", "content": "## 目录\n\n* [TAS2563](#TAS2563)\n* [RP2040实现IIS](#RP2040-IIS)\n* [时隙太小，很难不间断的传输数据](#time-slot)\n* [总结](#summary)\n\n最近使用tas2563做一个音频相关的项目，想要快速验证方案，就选了用了rp2040作为主控。主要的考量是，rp2040官方加入了MicroPython的支持，在开发上占据一定的便利性。\n\n<h2 id=\"TAS2563\">TAS2563</h2>\n\ntas2563是德州仪器的一款6瓦单声道D类功放，自带DC-DC升压，在2.5v~5.5v电池供电的情况下升至11v，同时有着极高的信噪比和低失真度。它的音频数据接口为TDM，可以配置为标准IIS或者左对齐模式。数据手册中采样率相关的介绍：\n\n![](/static/new_blog/833dcb3d/2023-02-26/i2s.png)\n\n> The TDM serial audio port supports up to 16 32-bit time slots at 44.1/48 kHz, 8 32-bit time slots at a 88.2/96 kHz sample rate and 4 32-bit time slots at a 176.4/192 kHz sample rate. The device supports 2 time slots at 32 bits in width and 4 or 8 time slots at 16, 24 or 32 bits in width. Valid SBCLK to FSYNC ratios are 64, 96, 128, 192, 256, 384 and 512. The device will automatically detect the number of time slots and this does not need to be programmed.\n\n其中规定了SBCLK和FSYNC最低的时钟比是64，即每一帧数据至少要达到64bit，哪怕传输24bit（双声道48bit，后同理）、16bit甚至是8bit音频，也要在末尾添补0来凑齐64个时钟。这其实是个缺点，因为它强行拉高了SBCLK的时钟频率，进而也拉高了主控的时钟。\n\ntas2563的采样率最高支持96kHz，但过高的时钟频率对主控投喂数据的实效要求更高。通常认为44.1kHz的采样率已经有足够的声音表现。鉴于其总线要求，在这个采样率下，SBCLK的频率为2.8224Mhz，如果传输16bit音频，码率为1378 kbps，约172.3 KB/s。\n\n<h2 id=\"RP2040-IIS\">RP2040实现IIS</h2>\n\nrp2040没有IIS外设接口，但有两个PIO块，每个PIO块有4个状态机，共享32个槽位的指令缓存。实现一个IIS接口，只需要1个状态机就够了。由于每条指令占用一个状态机时钟，可以画出标准32bit IIS时序图：\n![](/static/new_blog/833dcb3d/2023-02-26/ana.jpg)\n对应的程序如下：\n```python\n@asm_pio(out_init=PIO.OUT_LOW, sideset_init=(PIO.OUT_HIGH, PIO.OUT_HIGH), pull_thresh=32, autopull=True, fifo_join=PIO.JOIN_TX,)\ndef Audio_PIO():\n    # SBCLK active: rising edge\n    #                              _ FSYNC\n    #                             / _ SBCLK\n    #                             |/\n    set(x, 15)            .side(0b11)\n    label(\"high_ch\")\n    out(pins, 1)          .side(0b10)\n    jmp(x_dec,\"high_ch\")  .side(0b11)\n\n    set(x, 13)            .side(0b10)\n    label(\"high_nop\")\n    nop()                 .side(0b11)\n    jmp(x_dec,\"high_nop\") .side(0b10)\n    nop()                 .side(0b11)\n    nop()                 .side(0b00)\n\n    set(x, 15)            .side(0b01)\n    label(\"low_ch\")\n    out(pins, 1)          .side(0b00)\n    jmp(x_dec,\"low_ch\")   .side(0b01)\n\n    set(x, 13)            .side(0b00)\n    label(\"low_nop\")\n    nop()                 .side(0b01)\n    jmp(x_dec,\"low_nop\")  .side(0b00)\n    nop()                 .side(0b01)\n    nop()                 .side(0b10)\n```\n\n在主循环中，往状态机中的tx FIFO写入数据0xAAAA_5555，左右声道各16bit ，从逻辑分析仪可以看到标准信号：\n![](/static/new_blog/833dcb3d/2023-02-26/rp2040_iis.png)\n\n实现了这一步，已经可以让tas2563发出声音了。但如果要让它播放歌曲，才是最困难的一步。如果所有音频都存储于ROM，那直接读取就好，几乎没有任何障碍。但这是不现实的，rp2040最大仅支持16MB的ROM，如果以wav格式存储44.1kHz 16bit音频，最多也只能存90秒。所以借助外部存储是有必要的。\n\n这可以借助SD卡，从MicroPython官方文档中ESP32的章节里，可以获取一个使用SPI总线操作SD卡的实例。可以无修改的移植到rp2040上，并挂载到文件系统中：\n```python\nimport os\nfrom machine import SPI, Pin\nfrom lib import SDCard  # 移植来的SD卡操作库\n\nsd = SDCard(spi=SPI(0, baudrate=60_000_000, sck=Pin(18), mosi=Pin(19), miso=Pin(16)), cs=Pin(17))\nos.mount(sd, '/sd')\n```\n这样一来，貌似可以在主程序中从sd卡读取文件，写入到状态机的tx FIFO里就可以播放音乐。但它还是有一个致命问题。\n\n<h2 id=\"time-slot\">时隙太小，很难不间断的传输数据</h2>\n\n在44.1 kHz的采样率下，每帧的时间间隔为22.6 us，IIS是一个 __时钟严格__ 的同步总线，如果下一帧数据没有在这个时隙中准备好，就会听到失真的声音甚至爆音。将状态机的rx FIFO和tx FIFO合并，得到8个32bit的FIFO，也仅有180多us，这个时隙太短了。\n\n读SD卡的延迟太高了，远远超过了180多us。这里特别强调是延迟，因为它的带宽还可以，不是真正的阻碍。即使采用spi总线，连续读的带宽也可轻松达到1MB/s，用来驱动这个IIS足够了。最大的还是延迟的问题，假如打开一个文件并读几个字节，等待时间有时高达数毫秒，这里有一部分是MicroPython的损耗，还有很大一部分是不可控的gc。同步读、同步写很难不卡的，只能借助一个更大的buffer实现异步操作。\n\n在只有264KB RAM的rp2040上，开辟一个20KB的array几乎是极限了，再大的话可能会超过堆的空间，产生MemoryError，这是MicroPython的限制。buffer分配好了，有两种方式把数据从SD卡上传到状态机里：\n* 在循环里一直读取数据，设置一个时隙稍小于180us周期性定时中断，在中断里把状态机的FIFO空间填满\n* rp2040是双核的，在一个核心里取数据，另一个核心写数据到状态机\n\n第一种方式，除非自己用C写扩展，否则无法实现。MicroPython官方的定时器，最小只能设置1ms的定时周期，已经大大超过了180us。即使如此，每次进入中断和离开中断，都有很大的性能损耗，这主要是mPy运行时和上下文切换的开销。\n\n而对于第二种方式，在两个核间共享数据，需要实现互斥锁。rp2040没有半传输中断机制，需要自己实现，在写buffer的core里不停轮训一个变量，以得知另一个core读取到buffer的哪个位置。这可能需要精细的控制时序，并且使用 [Maximising MicroPython speed](https://docs.micropython.org/en/latest/reference/speed_python.html) 技巧实现加速。但经过反复调试，还是很难保证每个180us时隙内都能取到有效数据，因为等待锁的时间是不可预知的，借助mPy文件系统读取sd卡过程中会申请内存、释放对象（即使使用了readinto到一个预申请的buff中，代替read），以及随机的gc，这些偶然因素都会造成抖动。用逻辑分析仪观察，它会偶尔出现一些空隙，造成爆音：\n![](/static/new_blog/833dcb3d/2023-02-26/bad_bus.png)\n\n\n<h2 id=\"summary\">总结</h2>\n\nMicroPython还是比较鸡肋。本来它和嵌入式应用场景就有些相悖，在264KB RAM的rp2040，光mPy运行时就占用了80多KB的RAM。各个模块的API也十分简略，比如ADC，它只能支持简单的单次转换，没有任何高阶功能。为了降低入门门槛、提高编程便捷性，在寸土寸金的硬件资源上，耗费了巨量的资源却只能实现很简略的功能，这个取舍到底是否值得，有待探讨。"}}, "tag_map": {"Python": ["2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei", "2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-"], "工程化": ["2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-"], "硬件": ["2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei"]}, "category_map": {"未分类": ["2023-02-26/MicroPython+rp2040-cao-zuo-IIS-hen-ji-lei", "2023-02-23/Python -xiang-dui-yin-yong-he-jue-dui-yin-yong--na-ge-geng-hao-"]}}